package com.healthcare.controller;
import org.modelmapper.ModelMapper;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.healthcare.dto.ApiResponse;
import com.healthcare.dto.FoodieSignUpDto;
import com.healthcare.dto.FoodieUpdateDto;
import com.healthcare.entities.Creator;
import com.healthcare.entities.Foodie;
import com.healthcare.entities.User;
import com.healthcare.entities.UserType;
import com.healthcare.exception_handler.FoodieConflictException;
import com.healthcare.exception_handler.ResourceAlreadyExistsException;
import com.healthcare.service.FoodieService;
import com.healthcare.service.UserService;

import jakarta.validation.Valid;
import lombok.AllArgsConstructor;

//@CrossOrigin(origins = "http://localhost:5173")
@RestController
@RequestMapping("foodies")
@AllArgsConstructor
public class FoodieController {

	// dependencies		

	private final UserService serviceImpl;
	private final FoodieService foodieService ;
	private final ModelMapper modelMapper;

	@GetMapping("list")
	public ResponseEntity<?> listAll(){
		foodieService.findAll().forEach(s->System.out.println(s));
		return ResponseEntity.ok(foodieService.findAll());
	}
	

	@PostMapping("{id}/updateDetails")
	public ResponseEntity<?> updateFoodie(@PathVariable Long id,@Valid @RequestBody FoodieUpdateDto dto)
	{
		Foodie f = foodieService.findById(id);
		User u = serviceImpl.findById(f.getUserId().getId());
		String str = "";
		
		if(dto.getEmail()!=null) {
			u.setEmail(dto.getEmail());
			str+=" email,";
		}
		if(dto.getFirstName()!=null) {
			u.setFirstName(dto.getFirstName());
			str+=" firstname,";
		}
		if(dto.getGender()!=null) {
			u.setGender(dto.getGender());
			str+=" gender,";
		}
		if(dto.getLastName()!=null) {
			u.setLastName(dto.getLastName());
			str+=" lastname,";
		}
		if(dto.getPassword()!=null) {
			u.setPassword(dto.getPassword());
			str+=" password,";
		}
		if(dto.getUsername()!=null) {
			u.setUsername(dto.getUsername());
			str+=" username,";
		}
		
		serviceImpl.updateUser(u);
		if(str.length()>0) {				
			return ResponseEntity.status(HttpStatus.OK).body(new ApiResponse<String>("Updated "+str.substring(0, str.length()-1),true,"Update successfull"));
		}
		else {
			return ResponseEntity.status(HttpStatus.OK).body(new ApiResponse<String>("No distint credentials were provided",false,"No update"));
		}
	}
	
	@PostMapping("/signUp")
	public ResponseEntity<?> newFoodie(@Valid @RequestBody FoodieSignUpDto dto){
				
		// validate email
		if(serviceImpl.emailExist(dto.getEmail())) {
			throw new RuntimeException("Email id should be unique");				
		}
				
		// validate creator name
		if(!serviceImpl.ifExist(dto.getUsername())) {
			
			User newUser = modelMapper.map(dto, User.class);
//				serviceImpl.signUp(newUser);
			newUser.setType(UserType.FOODIE);
			Foodie newFoodie = new Foodie();
			newFoodie.setUserId(newUser);			
			foodieService.addFoodie(newFoodie);
			return ResponseEntity.status(HttpStatus.CREATED).body(new ApiResponse<String>("Welcome "+dto.getFirstName(),true,"SignUp successfull"));				
		}
		else {
			throw new ResourceAlreadyExistsException("Foodie name should be unique");
		}
	}

	@Transactional
	@GetMapping("{foodie_id}/followCreator")
	public ResponseEntity<?> followCreator(@Valid @PathVariable Long foodie_id, @RequestParam Long creator_id){			
		// get persistant foodie by id
		Foodie f = foodieService.findByIdWithCreators(foodie_id);
		
		if(
			f.getCreators()
		    .stream()
		    .anyMatch(s -> s.getC_id()==(creator_id))	
			) {
			throw new FoodieConflictException("Foodie is already following creator: "+creator_id);
		}
		
		Creator c = foodieService.findCreatorWithFoodies(creator_id);
		// insert creator to set or following list
		f.getCreators().add(c);
		
		// commit changes
		foodieService.updateFoodie(f);
		
		return ResponseEntity.ok("Foodie: "+foodie_id+" now follows Creator: "+creator_id);
		
	}
	
	@Transactional
	@GetMapping("{foodie_id}/unfollowCreator")
	public ResponseEntity<?> unfollowCreator(@Valid @PathVariable Long foodie_id, @RequestParam Long creator_id){			
		// get persistant foodie by id
		Foodie f = foodieService.findByIdWithCreators(foodie_id);
		
		if(
			f.getCreators()
		    .stream()
		    .anyMatch(s -> s.getC_id()==(creator_id))	
			) {
			
			// 
			Creator c = foodieService.findCreatorWithFoodies(creator_id);
			// insert creator to set or following list
			f.getCreators().remove(c;
			
			// commit changes
			foodieService.updateFoodie(f);
			
			return ResponseEntity.ok("Foodie: "+foodie_id+" now follows Creator: "+creator_id);
			
		}
		throw new FoodieConflictException("Foodie doesn't follow creator: "+creator_id);
		
	}
	
	
}
